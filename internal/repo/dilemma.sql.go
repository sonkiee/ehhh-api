// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: dilemma.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDilemma = `-- name: CreateDilemma :one
INSERT INTO
    dilemmas (user_id, title, is_anonymous)
VALUES ($1, $2, $3)
RETURNING
    id, user_id, title, is_anonymous, status, total_votes, created_at
`

type CreateDilemmaParams struct {
	UserID      pgtype.UUID `json:"user_id"`
	Title       string      `json:"title"`
	IsAnonymous bool        `json:"is_anonymous"`
}

func (q *Queries) CreateDilemma(ctx context.Context, arg CreateDilemmaParams) (Dilemma, error) {
	row := q.db.QueryRow(ctx, createDilemma, arg.UserID, arg.Title, arg.IsAnonymous)
	var i Dilemma
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.IsAnonymous,
		&i.Status,
		&i.TotalVotes,
		&i.CreatedAt,
	)
	return i, err
}

const createDilemmaOption = `-- name: CreateDilemmaOption :one
INSERT INTO
    dilemma_options (dilemma_id, label)
VALUES ($1, $2)
RETURNING
    id, dilemma_id, label, vote_count
`

type CreateDilemmaOptionParams struct {
	DilemmaID pgtype.UUID `json:"dilemma_id"`
	Label     string      `json:"label"`
}

func (q *Queries) CreateDilemmaOption(ctx context.Context, arg CreateDilemmaOptionParams) (DilemmaOption, error) {
	row := q.db.QueryRow(ctx, createDilemmaOption, arg.DilemmaID, arg.Label)
	var i DilemmaOption
	err := row.Scan(
		&i.ID,
		&i.DilemmaID,
		&i.Label,
		&i.VoteCount,
	)
	return i, err
}

const getDilemma = `-- name: GetDilemma :one
SELECT id, user_id, title, is_anonymous, status, total_votes, created_at FROM dilemmas WHERE id = $1
`

func (q *Queries) GetDilemma(ctx context.Context, id pgtype.UUID) (Dilemma, error) {
	row := q.db.QueryRow(ctx, getDilemma, id)
	var i Dilemma
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Title,
		&i.IsAnonymous,
		&i.Status,
		&i.TotalVotes,
		&i.CreatedAt,
	)
	return i, err
}

const getDilemmaOptions = `-- name: GetDilemmaOptions :many
SELECT id, dilemma_id, label, vote_count FROM dilemma_options WHERE dilemma_id = $1 ORDER BY id
`

func (q *Queries) GetDilemmaOptions(ctx context.Context, dilemmaID pgtype.UUID) ([]DilemmaOption, error) {
	rows, err := q.db.Query(ctx, getDilemmaOptions, dilemmaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DilemmaOption
	for rows.Next() {
		var i DilemmaOption
		if err := rows.Scan(
			&i.ID,
			&i.DilemmaID,
			&i.Label,
			&i.VoteCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeed = `-- name: ListFeed :many
SELECT d.id, d.title, d.is_anonymous, d.total_votes, d.created_at, u.username AS author_username
FROM dilemmas d
    JOIN users u ON u.id = d.user_id
WHERE
    d.status = 'active'
ORDER BY d.created_at DESC
LIMIT $1
OFFSET
    $2
`

type ListFeedParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListFeedRow struct {
	ID             pgtype.UUID        `json:"id"`
	Title          string             `json:"title"`
	IsAnonymous    bool               `json:"is_anonymous"`
	TotalVotes     int32              `json:"total_votes"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	AuthorUsername string             `json:"author_username"`
}

func (q *Queries) ListFeed(ctx context.Context, arg ListFeedParams) ([]ListFeedRow, error) {
	rows, err := q.db.Query(ctx, listFeed, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListFeedRow
	for rows.Next() {
		var i ListFeedRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.IsAnonymous,
			&i.TotalVotes,
			&i.CreatedAt,
			&i.AuthorUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
